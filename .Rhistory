dyn.unload(x = "mnormt")
.Renviron
.Renviron()
Renviron
Sys.setenv(R_MAX_NUM_DLLS = 150)
require(pRoloc)
normalizePath("~/.Renviron", mustWork = FALSE)
normalizePath("~/.Renviron", mustWork = FALSE)
source('C:/Users/OllyC/Desktop/bayesian-spatial-proteomics/code/BayesGMM/GPcode/hamiltonianGP.R')
source('C:/Users/OllyC/Desktop/bayesian-spatial-proteomics/code/BayesGMM/GPcode/hamiltonianGP.R')
source('C:/Users/OllyC/Desktop/bayesian-spatial-proteomics/code/BayesGMM/GPcode/metropolisGP.R')
metropolisRes <- metropolisGP(inith = c(-0.5,-2, -0.6), X = Xk, tau = tau,nk = 20,D = 5,niter = 10000)
source('C:/Users/OllyC/Desktop/bayesian-spatial-proteomics/code/BayesGMM/GPcode/metropolisGP.R')
metropolisRes <- metropolisGP(inith = c(-0.5,-2, -0.6), X = Xk, tau = tau,nk = 20,D = 5,niter = 10000)
source('C:/Users/OllyC/Desktop/bayesian-spatial-proteomics/code/BayesGMM/GPcode/metropolisGP.R')
metropolisRes <- metropolisGP(inith = c(-0.5,-2, -0.6), X = Xk, tau = tau,nk = 20,D = 5,niter = 10000)
source('C:/Users/OllyC/Desktop/bayesian-spatial-proteomics/code/BayesGMM/GPcode/metropolisGP.R')
metropolisRes <- metropolisGP(inith = c(-0.5,-2, -0.6), X = Xk, tau = tau,nk = 20,D = 5,niter = 10000)
source('C:/Users/OllyC/Desktop/bayesian-spatial-proteomics/code/BayesGMM/GPcode/metropolisGP.R')
metropolisRes <- metropolisGP(inith = c(-0.5,-2, -0.6), X = Xk, tau = tau,nk = 20,D = 5,niter = 10000)
metropolisRes$ar
rowMeans(metropolisRes$h)
plot(metropolisRes$h[,1])
plot(metropolisRes$h[1,])
head(metroplisRes$h[1,])
head(metropolisRes$h[1,])
source('C:/Users/OllyC/Desktop/bayesian-spatial-proteomics/code/BayesGMM/GPcode/metropolisGP.R')
metropolisRes <- metropolisGP(inith = c(-0.5,-2, -0.6), X = Xk, tau = tau,nk = 20,D = 5,niter = 10000)
plot(metropolisRes$h[1,])
mean(metropolisRes$h[1,])
mean(metropolisRes$h[2,])
mean(metropolisRes$h[3,])
source('C:/Users/OllyC/Desktop/bayesian-spatial-proteomics/code/BayesGMM/GPcode/hamiltonianGP.R')
hamiltonianRes <- hamiltonianGP(c(-0.5,-2, -0.6),tau = tau, X = Xk, nk = 20, D = 5, niter = 300)
plot(hamiltonianRes$h[1,])
plot(hamiltonianRes$h[1,], type = "b")
plot(hamiltonianRes$h[2,], type = "b")
plot(hamiltonianRes$h[3,], type = "b")
mean(hamiltonianRes$h[1,])
mean(hamiltonianRes$h[2,])
mean(hamiltonianRes$h[3,])
mean(hamiltonianRes$h[1,-(1:10)])
mean(unique(hamiltonianRes$h)[1,-(1:10)])
mean(unique(hamiltonianRes$h)[2,-(1:10)])
mean(unique(hamiltonianRes$h)[3,-(1:10)])
plot(unique(hamiltonianRes$h)[3,-(1:10)])
plot(unique(hamiltonianRes$h)[3,-(1:10)])
unique(hamiltonianRes$h[1,])
plot(unique(hamiltonianRes$h)[1,-(1:10)])
plot(unique(hamiltonianRes$h[3,-(1:10)]))
plot(unique(hamiltonianRes$h[1,-(1:10)]))
plot(unique(hamiltonianRes$h[2,-(1:10)]))
plot(unique(hamiltonianRes$h[3,-(1:10)]))
hamiltonianRes <- hamiltonianGP(c(-0.5,-2, -0.6),tau = tau, X = Xk, nk = 20, D = 5, niter = 1000)
plot(unique(hamiltonianRes$h[1,-(1:10)]))
plot(unique(hamiltonianRes$h[2,-(1:10)]))
plot(unique(hamiltonianRes$h[3,-(1:10)]))
plot(unique(hamiltonianRes$h[1,-(1:10)]), type = "b")
mean(unique(hamiltonianRes$h)[1,-(1:10)])
mean(unique(hamiltonianRes$h)[2,-(1:10)])
mean(unique(hamiltonianRes$h)[3,-(1:10)])
mean(unique(metropolisRes$h)[3,-(1:10)])
mean(unique(metropolisRes$h)[1,-(1:10)])
hamiltonianRes <- hamiltonianGP(c(0,-2, -0.6),tau = tau, X = Xk, nk = 20, D = 5, niter = 1000)
mean(unique(metropolisRes$h)[1,-(1:10)])
mean(unique(hamiltonianRes$h)[1,-(1:10)])
plot(unique(hamiltonianRes$h)[1,-(1:10)])
plot(unique(hamiltonianRes$h[1,-(1:10)]))
hamiltonianRes <- hamiltonianGP(c(0,-2, -0.6),tau = tau, X = Xk, nk = 20, D = 5, niter = 1000, stepsize = c(0.01,0.05))
plot(unique(hamiltonianRes$h)[1,-(1:10)])
plot(unique(hamiltonianRes$h[1,-(1:10)]))
hamiltonianRes <- hamiltonianGP(c(1,-2, -0.6),tau = tau, X = Xk, nk = 20, D = 5, niter = 1000, stepsize = c(0.01,0.05))
plot(unique(hamiltonianRes$h[1,-(1:10)]))
plot(unique(hamiltonianRes$h[2,-(1:10)]))
plot(unique(hamiltonianRes$h[3,-(1:10)]))
plot(unique(hamiltonianRes$h[1,-(1:10)]))
mean(unique(metropolisRes$h[1,-(1:10)]))
mean(unique(hamiltonianRes$h[1,-(1:10)]))
plot((unique(metropolisRes$h[1,-(1:10)])))
metropolisRes <- metropolisGP(inith = c(1,-2, -0.6), X = Xk, tau = tau,nk = 20,D = 5,niter = 20000)
plot((unique(metropolisRes$h[1,-(1:10)])))
mean(unique(hamiltonianRes$h[1,-(1:10)]))
mean(unique(metropolisRes$h[1,-(1:10)]))
metropolisRes <- metropolisGP(inith = c(1,-2, -0.6), X = Xk, tau = tau,nk = 20,D = 5,niter = 30000)
mean(unique(metropolisRes$h[1,-(1:10)]))
hamiltonianRes <- hamiltonianGP(c(1,-2, -0.6),tau = tau, X = Xk, nk = 20, D = 5, niter = 1000, stepsize = c(0.04,0.05))
plot((unique(metropolisRes$h[1,-(1:10)])))
mean(unique(hamiltonianRes$h[1,-(1:10)]))
plot(unique(hamiltonianRes$h[1,-(1:10)]))
plot(unique(hamiltonianRes$h[2,-(1:10)]))
plot(unique(hamiltonianRes$h[2,-(1:40)]))
plot(unique(hamiltonianRes$h[1,-(1:40)]))
plot(unique(hamiltonianRes$h[3,-(1:40)]))
init <- seq(-3,3, 0.1)
initz <- matrix(0,length(init),3)
for(i in seq_along(init)){
initz[i,] <- init[sample.int(length(init), size = 3, replace = T)]
}
tau <- seq_along(idx)
nk <- length(X)/max(idx)
D <- 20
res <- apply(initz, 1,function(z){lbfgs(likelihoodGP,
gradientGP,
vars = z,
invisible=1,
epsilon = 1e-8,
Xk = as.vector(t(X)),
tau = seq_along(idx),
nk = length(X)/max(idx),
D = 20)})
require(lbfgs)
Rcpp::sourceCpp('C:/Users/OllyC/Desktop/bayesian-spatial-proteomics/code/BayesGMM/GPcode/leapfrogGPcpp.cpp')
Rcpp::sourceCpp('C:/Users/OllyC/Desktop/bayesian-spatial-proteomics/code/BayesGMM/GPcode/leapfrogGPcpp.cpp')
require(RcppArmadillo)
install.packages("RcppArmadillo")
require(RcppArmadillo)
Rcpp::sourceCpp('C:/Users/OllyC/Desktop/bayesian-spatial-proteomics/code/BayesGMM/GPcode/leapfrogGPcpp.cpp')
source('C:/Users/OllyC/Desktop/bayesian-spatial-proteomics/code/BayesGMM/GPcode/hamiltonianGP.R')
require(mvnorm)
require(mvtnorm)
require(pRoloc)
require(pRolocdata)
require(MSnbase)
require(XML)
source("https://bioconductor.org/biocLite.R")
biocLite()
require(MSnbase)
install.packages("XML")
require(MSnbase)
require(rlang)
install.packages(rlang)
install.packages("rlang")
require(MSnbase)
install.packages("rlimma")
install.packages("rimma")
install.packages("limma")
require(installr)
install.packages("installr")
require(installr)
require(stringr)
installr::updateR()
install.packages("stringi")
require(stringi)
installr::updateR()
require(MSnbase)
install.packages("limma")
version
install.packages("limma")
require(MSnbase)
install.packages("Rcpp")
require(MSnbase)
require(Rcpp)
install.packages("Rcpp")
require(Rcpp)
Sys.getenv("R_LIBS_USER")
remove.packages("Rcpp")
install.packages("Rcpp")
install.packages("Rcpp")
require(MSnbase)
require(pRoloc)
require(MSnbase)
install.packages("limma")
source("https://bioconductor.org/biocLite.R")
biocLite()
source("https://bioconductor.org/biocLite.R")
biocLite()
require(MSnbase)
source("https://bioconductor.org/biocLite.R")
biocLite("limma")
require(MSnbase)
require(pRoloc)
biocLite("pRoloc")
require(pRoloc)
install.packages("AnnotationDbi")
biocLite("AnnotationDbi")
require(pRoloc)
biocLite("MLInterfaces")
require(pRoloc)
biocLite("Matrix")
require(pRoloc)
require(MSnbase)
require(pRolocdata)
Rcpp::sourceCpp('C:/Users/OllyC/Desktop/bayesian-spatial-proteomics/code/BayesGMM/GPcode/leapfrogGPcpp.cpp')
require(mvtnorm)
source('C:/Users/OllyC/Desktop/bayesian-spatial-proteomics/code/BayesGMM/GPcode/hamiltonianGP.R')
data("hyperLOPIT2015")
hlnorm <- normalise(hyperLOPIT2015, method = "quantiles")
hlnorm <- normalise(hyperLOPIT2015, method = "center.mean")
1/c(1,1,100)
source('C:/Users/OllyC/Desktop/bayesian-spatial-proteomics/code/BayesGMM/GPcode/hamiltonianGP.R')
exprs <- as.vector(t(exprs(hlnorm[fData(hlnorm)$markers == getMarkerClasses(hlnorm)[4],idx])))
require(pRoloc)
install.packages("MLInterfaces")
biocLite()
require(pRoloc)
source("https://bioconductor.org/biocLite.R")
biocLite()
require(pRoloc)
biocLite("MLInterfaces")
require(pRoloc)
remove.packages("cluster")
source("https://bioconductor.org/biocLite.R")
biocLite()
biocLite("cluster")
B <- 1000
n <- 25
M <- 3
pmax <- 20
x <- rep(seq(from = -10, to = 10, length = n), each = M)
mu <- function(x) {8 * exp(q(x))}
q <- function(x) {0.001 * (100 + x + x^2 + x^3)}
aics <- matrix(0, nrow = B, ncol = p)
for (b in 1:B) {
y <- rpois(n = M * n, lambda = mu(x))
mod <- glm(y ~ 1, family = poisson)
aics[b, 1] <- AIC(mod)
formula <- "y~x"
mod <- glm(formula, family = poisson)
aics[b, 2] <- AIC(mod)
for (j in 3:pmax) {
formula <- paste(formula, " + I(x^", j - 1, ")", sep = "")
od <- glm(formula, family = poisson)
aics[b, j] <- AIC(mod)
}
}
AICorder <- apply(aics, 1, which.min) - 1
tAIC <- table(AICorder)
tAIC
B <- 1000
n <- 25
M <- 3
pmax <- 20
x <- rep(seq(from = -10, to = 10, length = n), each = M)
mu <- function(x) {8 * exp(q(x))}
q <- function(x) {0.001 * (100 + x + x^2 + x^3)}
aics <- matrix(0, nrow = B, ncol = pmax)
for (b in 1:B) {
y <- rpois(n = M * n, lambda = mu(x))
mod <- glm(y ~ 1, family = poisson)
aics[b, 1] <- AIC(mod)
formula <- "y~x"
mod <- glm(formula, family = poisson)
aics[b, 2] <- AIC(mod)
for (j in 3:pmax) {
formula <- paste(formula, " + I(x^", j - 1, ")", sep = "")
od <- glm(formula, family = poisson)
aics[b, j] <- AIC(mod)
}
}
AICorder <- apply(aics, 1, which.min) - 1
tAIC <- table(AICorder)
tAIC
aics
AICorder
tAIC
B <- 1000
n <- 50
M <- 3
pmax <- 20
x <- rep(seq(from = -10, to = 10, length = n), each = M)
mu <- function(x) {8 * exp(q(x))}
q <- function(x) {0.001 * (100 + x + x^2 + x^3)}
aics <- matrix(0, nrow = B, ncol = pmax)
for (b in 1:B) {
y <- rpois(n = M * n, lambda = mu(x))
mod <- glm(y ~ 1, family = poisson)
aics[b, 1] <- AIC(mod)
formula <- "y~x"
mod <- glm(formula, family = poisson)
aics[b, 2] <- AIC(mod)
for (j in 3:pmax) {
formula <- paste(formula, " + I(x^", j - 1, ")", sep = "")
od <- glm(formula, family = poisson)
aics[b, j] <- AIC(mod)
}
}
AICorder <- apply(aics, 1, which.min) - 1
tAIC <- table(AICorder)
tAIC
B <- 1000
n <- 100
M <- 3
pmax <- 20
x <- rep(seq(from = -10, to = 10, length = n), each = M)
mu <- function(x) {8 * exp(q(x))}
q <- function(x) {0.001 * (100 + x + x^2 + x^3)}
aics <- matrix(0, nrow = B, ncol = pmax)
for (b in 1:B) {
y <- rpois(n = M * n, lambda = mu(x))
mod <- glm(y ~ 1, family = poisson)
aics[b, 1] <- AIC(mod)
formula <- "y~x"
mod <- glm(formula, family = poisson)
aics[b, 2] <- AIC(mod)
for (j in 3:pmax) {
formula <- paste(formula, " + I(x^", j - 1, ")", sep = "")
od <- glm(formula, family = poisson)
aics[b, j] <- AIC(mod)
}
}
AICorder <- apply(aics, 1, which.min) - 1
tAIC <- table(AICorder)
tAIC
B <- 1000
n <- 1000
M <- 3
pmax <- 20
x <- rep(seq(from = -10, to = 10, length = n), each = M)
mu <- function(x) {8 * exp(q(x))}
q <- function(x) {0.001 * (100 + x + x^2 + x^3)}
aics <- matrix(0, nrow = B, ncol = pmax)
for (b in 1:B) {
y <- rpois(n = M * n, lambda = mu(x))
mod <- glm(y ~ 1, family = poisson)
aics[b, 1] <- AIC(mod)
formula <- "y~x"
mod <- glm(formula, family = poisson)
aics[b, 2] <- AIC(mod)
for (j in 3:pmax) {
formula <- paste(formula, " + I(x^", j - 1, ")", sep = "")
od <- glm(formula, family = poisson)
aics[b, j] <- AIC(mod)
}
}
AICorder <- apply(aics, 1, which.min) - 1
tAIC <- table(AICorder)
tAIC
aics
B <- 1000
n <- 25
M <- 3
pmax <- 20
x <- rep(seq(from = -10, to = 10, length = n), each = M)
mu <- function(x) {8 * exp(q(x))}
q <- function(x) {1.2/(1 + exp(-x))}
aics <- matrix(0, nrow = B, ncol = pmax)
for (b in 1:B) {
y <- rpois(n = M * n, lambda = mu(x))
mod <- glm(y ~ 1, family = poisson)
aics[b, 1] <- AIC(mod)
formula <- "y~x"
mod <- glm(formula, family = poisson)
aics[b, 2] <- AIC(mod)
for (j in 3:pmax) {
formula <- paste(formula, " + I(x^", j - 1, ")", sep = "")
od <- glm(formula, family = poisson)
aics[b, j] <- AIC(mod)
}
}
AICorder <- apply(aics, 1, which.min) - 1
tAIC <- table(AICorder)
tAIC
BIC(mod)
B <- 1000
n <- 50
M <- 3
pmax <- 20
x <- rep(seq(from = -10, to = 10, length = n), each = M)
mu <- function(x) {8 * exp(q(x))}
q <- function(x) {1.2/(1 + exp(-x))}
aics <- matrix(0, nrow = B, ncol = pmax)
for (b in 1:B) {
y <- rpois(n = M * n, lambda = mu(x))
mod <- glm(y ~ 1, family = poisson)
aics[b, 1] <- AIC(mod)
formula <- "y~x"
mod <- glm(formula, family = poisson)
aics[b, 2] <- AIC(mod)
for (j in 3:pmax) {
formula <- paste(formula, " + I(x^", j - 1, ")", sep = "")
od <- glm(formula, family = poisson)
aics[b, j] <- AIC(mod)
}
}
AICorder <- apply(aics, 1, which.min) - 1
tAIC <- table(AICorder)
tAIC
B <- 1000
n <- 25
M <- 3
pmax <- 20
x <- rep(seq(from = -10, to = 10, length = n), each = M)
mu <- function(x) {8 * exp(q(x))}
q <- function(x) {0.001 * (100 + x + x^2 + x^3)}
aics <- matrix(0, nrow = B, ncol = pmax)
bics <- matrix(0, nrow = B, ncol = pmax)
aiccs <- matrix(0, nrow = B, ncol = pmax)
for (b in 1:B) {
y <- rpois(n = M * n, lambda = mu(x))
mod <- glm(y ~ 1, family = poisson)
aics[b, 1] <- AIC(mod)
bics[b, 1] <- BIC(mod)
aiccs[b, 1] <- aics[b, 1] + (2 + 2)/(n - 2)
formula <- "y~x"
mod <- glm(formula, family = poisson)
aics[b, 2] <- AIC(mod)
bics[b, 2] <- BIC(mod)
aiccs[b, 2] <- aics[b, 2] + (2*2^2 + 2*2)/(n - 2 - 1)
for (j in 3:pmax) {
formula <- paste(formula, " + I(x^", j - 1, ")", sep = "")
od <- glm(formula, family = poisson)
aics[b, j] <- AIC(mod)
bics[b, j] <- BIC(mod)
aiccs[b, j] <- aics[b, j] + (2*j^2 + 2*j)/(n - j - 1)
}
}
B <- 1000
n <- 25
M <- 3
pmax <- 20
x <- rep(seq(from = -10, to = 10, length = n), each = M)
mu <- function(x) {8 * exp(q(x))}
q <- function(x) {0.001 * (100 + x + x^2 + x^3)}
aics <- matrix(0, nrow = B, ncol = pmax)
bics <- matrix(0, nrow = B, ncol = pmax)
aiccs <- matrix(0, nrow = B, ncol = pmax)
for (b in 1:B) {
y <- rpois(n = M * n, lambda = mu(x))
mod <- glm(y ~ 1, family = poisson)
aics[b, 1] <- AIC(mod)
bics[b, 1] <- BIC(mod)
aiccs[b, 1] <- aics[b, 1] + (2 + 2)/(n - 2)
formula <- "y~x"
mod <- glm(formula, family = poisson)
aics[b, 2] <- AIC(mod)
bics[b, 2] <- BIC(mod)
aiccs[b, 2] <- aics[b, 2] + (2*2^2 + 2*2)/(n - 2 - 1)
for (j in 3:pmax) {
formula <- paste(formula, " + I(x^", j - 1, ")", sep = "")
mod <- glm(formula, family = poisson)
aics[b, j] <- AIC(mod)
bics[b, j] <- BIC(mod)
aiccs[b, j] <- aics[b, j] + (2*j^2 + 2*j)/(n - j - 1)
}
}
AICorder <- apply(aics, 1, which.min) - 1
BICorder <- apply(bics, 1, which.min) - 1
AICcorder <- apply(aiccs, 1, which.min) - 1
tAIC <- table(AICorder)
tBIC <- table(BICorder)
tAICc <- table(AICcorder)
tAIC
tBIC
tAICc
AICorder
table(AICorder,BICorder)
heatplot(table(AICorder,BICorder))
heatmap(table(AICorder,BICorder))
lattice(table(AICorder,BICorder)
lattice(table(AICorder,BICorder))
image(table(AICorder,BICorder))
?image
?heatmap
heatmap(table(AICorder,BICorder), Rowv = NULL, Colv = NULL)
heatmap(table(AICorder,BICorder), Rowv = NULL, Colv = NULL, scale = none)
heatmap(table(AICorder,BICorder), Rowv = NULL, Colv = NULL, scale = "none")
heatmap(table(AICorder,BICorder), Rowv = NA, Colv = NA, scale = "none")
heatmap(table(AICorder,BICorder), Rowv = NA, Colv = NA)
heatmap(table(AICcorder, BICorder), Rowv = NA, Colv = NA)
B <- 1000
n <- 25
M <- 3
pmax <- 20
x <- rep(seq(from = -10, to = 10, length = n), each = M)
mu <- function(x) {8 * exp(q(x))}
q <- function(x) {1.2/(1 + exp(-x))}
aics <- matrix(0, nrow = B, ncol = pmax)
bics <- matrix(0, nrow = B, ncol = pmax)
aiccs <- matrix(0, nrow = B, ncol = pmax)
for (b in 1:B) {
y <- rpois(n = M * n, lambda = mu(x))
mod <- glm(y ~ 1, family = poisson)
aics[b, 1] <- AIC(mod)
bics[b, 2] <- BIC(mod)
aiccs[b, 2] <- aics[b, 2] + (2*2^2 + 2*2)/(n - 2 - 1)
for (j in 3:pmax) {
formula <- paste(formula, " + I(x^", j - 1, ")", sep = "")
mod <- glm(formula, family = poisson)
aics[b, j] <- AIC(mod)
bics[b, j] <- BIC(mod)
aiccs[b, j] <- aics[b, j] + (2*j^2 + 2*j)/(n - j - 1)
}
}
AICorder <- apply(aics, 1, which.min) - 1
tAIC <- table(AICorder)
tAIC
tBIC <- table(BICorder)
tAICc <- table(AICcorder)
tAIC
tBIC
tAICc
heatmap(table(AICorder,BICorder), Rowv = NA, Colv = NA)
heatmap(table(AICcorder, BICorder), Rowv = NA, Colv = NA)
x
q(x)
roxygen2::roxygenize()
setwd("C:/Users/OllyC/Desktop/sugsvarsel")
roxygen2::roxygenize()
require(sugsvarsel)
roxygen2::roxygenize()
devtools::check_cran()
devtools::check_cran("sugsvarsel")
devtools::check()
devtools::build()
require(yaml)
install.packages(yaml)
install.packages("yaml")
require(yaml)
devtools::build()
devtools::check()
?devtools::check()
devtools::check(cran = TRUE)
